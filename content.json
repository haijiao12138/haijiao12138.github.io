{"pages":[],"posts":[{"title":"linux基础命令","text":"1-查看日志-tail 当日志文件存储日志很大时，我们就不能用vi直接进去查看日志，需要Linux的命令去完成我们的查看任务. 12345678910实例： 1、tail -f filename 说明：监视filename文件的尾部内容（默认10行，相当于增加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。 2、tail -n 20 filename 说明：显示filename最后20行。 3、tail -r -n 10 filename 说明：逆序显示filename最后10行。 128陷阱简单一点讲装箱就是基本数据类型自动转换为包装类，拆箱与之对应，包装类自动转换为基本数据类型. //自动装箱 Integer s = 123; //上面语句其实相当于这条语句 Integer ss = Integer.valueOf(123); 装箱就是自动将基本数据类型转换为包装器类型； 拆箱就是自动将包装器类型转换为基本数据类型。 首先final修饰类，代表这个类不能被继承，也就没有任何办法去继承 final修饰变量：不能指向新的对象，可以改变对象中变量的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Test{public static void main(String[] args) { int a1 = 30; int a2 = 30; // 值比较：true System.out.println(a1 == a2); int b1 = 130; int b2 = 130; // 值比较：true System.out.println(b1 == b2); Integer c1 = 30; Integer c2 = 30; // 类比较，但在-127～128之间，属于常量：true System.out.println(c1 == c2); Integer d1 = 130; Integer d2 = 130; // 类比较，不在-127～128之间，属于新建对象：false System.out.println(d1 == d2); Integer e1 = 130; Integer e2 = 130; // 类转为数值比较：true System.out.println(e1.intValue() == e1.intValue()); Integer f1 = 130; int f2 = 130; // f1自动拆箱，不涉及128陷阱，与f2比较：true System.out.println(f1 == f2); long g1 = 30; long g2 = 30; // 值比较：true System.out.println(g1 == g2); long h1 = 130; long h2 = 130; // 值比较：true System.out.println(h1 == h2); Long i1 = 30l; Long i2 = 30l; // 类比较，但在-127～128之间，属于常量：true System.out.println(i1 == i2); Long g1 = 130l; Long g2 = 130l; // 类比较，不在-127～128之间，属于新建对象：false System.out.println(g1 == g2); Long k1 = 130l; Long k2 = 130l; // 类转为数值比较：true System.out.println(k1.longValue() == k2.longValue()); Integer l1 = 130l; int l2 = 130l; // l1自动拆箱，不涉及128陷阱，与l2比较：true System.out.println(l1 == l2); }} 输入与输出for-each循环；for(int i: a) 第三章-对象和类（OOP）抽象-封装-集成-多态； static修饰的都是归类所有的 很多歌对象共享一个类 ； 静态方法不能访问普通的私有域 出栈了 导致作用域辩护的那些都消失了 回归本源了 构造函数总是在最后执行，初始化语句是从上往下顺序执行的；","link":"/2021/06/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"java_basic","text":"128陷阱简单一点讲装箱就是基本数据类型自动转换为包装类，拆箱与之对应，包装类自动转换为基本数据类型. //自动装箱 Integer s = 123; //上面语句其实相当于这条语句 Integer ss = Integer.valueOf(123); 装箱就是自动将基本数据类型转换为包装器类型； 拆箱就是自动将包装器类型转换为基本数据类型。 首先final修饰类，代表这个类不能被继承，也就没有任何办法去继承 final修饰变量：不能指向新的对象，可以改变对象中变量的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Test{public static void main(String[] args) { int a1 = 30; int a2 = 30; // 值比较：true System.out.println(a1 == a2); int b1 = 130; int b2 = 130; // 值比较：true System.out.println(b1 == b2); Integer c1 = 30; Integer c2 = 30; // 类比较，但在-127～128之间，属于常量：true System.out.println(c1 == c2); Integer d1 = 130; Integer d2 = 130; // 类比较，不在-127～128之间，属于新建对象：false System.out.println(d1 == d2); Integer e1 = 130; Integer e2 = 130; // 类转为数值比较：true System.out.println(e1.intValue() == e1.intValue()); Integer f1 = 130; int f2 = 130; // f1自动拆箱，不涉及128陷阱，与f2比较：true System.out.println(f1 == f2); long g1 = 30; long g2 = 30; // 值比较：true System.out.println(g1 == g2); long h1 = 130; long h2 = 130; // 值比较：true System.out.println(h1 == h2); Long i1 = 30l; Long i2 = 30l; // 类比较，但在-127～128之间，属于常量：true System.out.println(i1 == i2); Long g1 = 130l; Long g2 = 130l; // 类比较，不在-127～128之间，属于新建对象：false System.out.println(g1 == g2); Long k1 = 130l; Long k2 = 130l; // 类转为数值比较：true System.out.println(k1.longValue() == k2.longValue()); Integer l1 = 130l; int l2 = 130l; // l1自动拆箱，不涉及128陷阱，与l2比较：true System.out.println(l1 == l2); }} 输入与输出for-each循环；for(int i: a) 第三章-对象和类（OOP）抽象-封装-集成-多态； static修饰的都是归类所有的 很多歌对象共享一个类 ； 静态方法不能访问普通的私有域 出栈了 导致作用域辩护的那些都消失了 回归本源了 构造函数总是在最后执行，初始化语句是从上往下顺序执行的；","link":"/2021/06/10/java_basic/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/07/10/hello-world/"},{"title":"test","text":"","link":"/2021/07/10/test/"},{"title":"Leetcode算法集合","text":"981. 基于时间的键值存储123456789101112创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：1. set(string key, string value, int timestamp)存储键 key、值 value，以及给定的时间戳 timestamp。2. get(string key, int timestamp)返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &lt;= timestamp。如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。如果没有值，则返回空字符串（&quot;&quot;）。 123456789101112131415161718192021222324252627282930示例 1：输入：inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]输出：[null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]解释： TimeMap kv; kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // 存储键 &quot;foo&quot; 和值 &quot;bar&quot; 以及时间戳 timestamp = 1 kv.get(&quot;foo&quot;, 1); // 输出 &quot;bar&quot; kv.get(&quot;foo&quot;, 3); // 输出 &quot;bar&quot; 因为在时间戳 3 和时间戳 2 处没有对应 &quot;foo&quot; 的值，所以唯一的值位于时间戳 1 处（即 &quot;bar&quot;） kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4); kv.get(&quot;foo&quot;, 4); // 输出 &quot;bar2&quot; kv.get(&quot;foo&quot;, 5); // 输出 &quot;bar2&quot; 示例 2：输入：inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;love&quot;,&quot;high&quot;,10],[&quot;love&quot;,&quot;low&quot;,20],[&quot;love&quot;,5],[&quot;love&quot;,10],[&quot;love&quot;,15],[&quot;love&quot;,20],[&quot;love&quot;,25]]输出：[null,null,null,&quot;&quot;,&quot;high&quot;,&quot;high&quot;,&quot;low&quot;,&quot;low&quot;] 提示：所有的键/值字符串都是小写的。所有的键/值字符串长度都在 [1, 100] 范围内。所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。1 &lt;= timestamp &lt;= 10^7TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/time-based-key-value-store著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12345678910111213141516class TimeMap { private HashMap&lt;String, TreeMap&lt;Integer, String&gt;&gt; map = new HashMap&lt;&gt;(); public void set(String key, String value, int timestamp) { if (!map.containsKey(key)) map.put(key, new TreeMap&lt;&gt;()); map.get(key).put(timestamp, value); } public String get(String key, int timestamp) { if (!map.containsKey(key)) return &quot;&quot;; Integer k = map.get(key).floorKey(timestamp); return null != k ? map.get(key).get(k) : &quot;&quot;; }}","link":"/2021/07/10/leetcode/"}],"tags":[],"categories":[]}